# openjdk hotspot CDS parsor 
# working with CDS version 9 (openjdk 14)
# 2020-08-02  written by c0m0r1

import struct

CDS_NAME = "app-cds.jsa"
NUM_CDS_REGIONS = 9
JVM_IDENT_MAX = 256
NARROWOOPBASE = -1
SHAREDBASEADDRESS = 32 << 30 # see src/hotspot/share/runtime/globals.hpp
NARROW_KLASS_SHIFT = -1
SPACE_LIST = []

def off2addr(off):
    for i in range(1, len(SPACE_LIST)):
        if off < SPACE_LIST[i][1] :
            if SPACE_LIST[i][0]: # heap area
                return off - SPACE_LIST[i - 1][1] + SPACE_LIST[i - 1][2] + NARROWOOPBASE
            else: # non-heap area
                return off - SPACE_LIST[i - 1][1] + SPACE_LIST[i - 1][2] + SHAREDBASEADDRESS 

def compress_klass_ptr(p):
    assert(NARROW_KLASS_SHIFT != -1)
    return (p - SHAREDBASEADDRESS) >> NARROW_KLASS_SHIFT

def find_klass_ptr(needle):
    candidate_klass_list = []
    print("\n[*] try to found CDSed class %s"% needle)

    with open(CDS_NAME, "rb") as f:
        data = f.read()

    pos = data.find(needle)
    if pos == -1 :
        print("[*] class %s not exist in CDS archive"%needle, end = ": ")
    print("candidate text addr for %s"%needle, end = ": ")
    while pos != -1:
        if data[pos - 4 : pos - 2] == struct.pack("<h", len(needle)) and pos % 8 == 6:
            print(hex(pos - 6))
            break
        pos = data.find(needle, pos + 1)

    symbol_addr = off2addr(pos - 6)
        
    print("candidate symbol addr for %s" % needle , end = ": ")
    print(hex(symbol_addr))

    symbol = struct.pack("<Q", symbol_addr)

    pos = data.find(symbol)
    while pos != -1:
        candidate_klass_list.append(off2addr(pos - 0x18))
        pos = data.find(symbol, pos + 1)

    print("candidate klass addr for %s" % needle , end = ": ")
    print(list(map(hex,candidate_klass_list)))

    print("candidate compressed klass addr for %s" % needle , end = ": ")
    print(list(map(hex,map(compress_klass_ptr, candidate_klass_list))))

f = open(CDS_NAME, "rb")

magic = struct.unpack("<I",f.read(4))
print("magic : %x"%magic)
header_crc = struct.unpack("<I",f.read(4))
print("header_crc : %x" % header_crc)
version = struct.unpack("<I",f.read(4))
print("version : %x" % version)
assert(version != 9)
align = f.read(4)

for i in range(NUM_CDS_REGIONS):
    print("-------------------------")
    print("space %d"%i)
    print("-------------------------")
    crc = struct.unpack("<I",f.read(4))
    print("crc : %x"%crc)

    read_only = struct.unpack("<I",f.read(4))
    print("read_only  : %x"%read_only)
    allow_exec = struct.unpack("<I",f.read(4))
    print("allow_exec  : %x"%allow_exec)

    is_heap_region = struct.unpack("<I",f.read(4))
    print("is_heap_region  : %x"%is_heap_region)
    is_bitmap_region = struct.unpack("<I",f.read(4))
    print("is_bitmap_region  : %x"%is_bitmap_region)
    mapped_from_file = struct.unpack("<I",f.read(4))
    print("mapped_from_file  : %x"%mapped_from_file)
    
    file_offset = struct.unpack("<q",f.read(8))
    print("file_offset : 0x%x"%file_offset)
    mapping_offset = struct.unpack("<q",f.read(8))
    print("mapping_offset : 0x%x"%mapping_offset)
    used = struct.unpack("<q",f.read(8))
    print("used  : 0x%x"%used)
    
    oopmap_offset = struct.unpack("<q",f.read(8))
    print("oopmap_offset  : %x"%oopmap_offset)
    oopmap_size_in_bits = struct.unpack("<q",f.read(8))
    print("oopmap_size_in_bits  : %x"%oopmap_size_in_bits)
    mapped_base = struct.unpack("<q",f.read(8))
    print("mapped_base  : %x"%mapped_base)
    SPACE_LIST.append((is_heap_region[0], file_offset[0], mapping_offset[0]))
    print()
    
header_size = struct.unpack("<q",f.read(8))
print("header_size : 0x%x" % header_size)

alignment = struct.unpack("<q",f.read(8))
print("alignment : 0x%x" % alignment)
obj_alignment = struct.unpack("<l",f.read(4))
print("obj_alignment : 0x%x" % obj_alignment)

align = f.read(4)

narrow_oop_base = struct.unpack("<Q",f.read(8))
print("narrow_oop_base : 0x%x" % narrow_oop_base)
NARROWOOPBASE = narrow_oop_base[0]

narrow_oop_shift = struct.unpack("<l",f.read(4))
print("narrow_oop_shift : 0x%x" % narrow_oop_shift)

compact_strings = struct.unpack("<B",f.read(1))
print("compact_strings : 0x%x" % compact_strings)

align = f.read(3)

max_heap_size = struct.unpack("<q",f.read(8))
print("max_heap_size : 0x%x" % max_heap_size)

"""
UnscaledNarrowOop = 0
ZeroBasedNarrowOop = 1
DisjointBaseNarrowOop = 2
HeapBasedNarrowOop = 3
AnyNarrowOopMode = 4
"""
narrow_oop_mode = struct.unpack("<B",f.read(1))
print("narrow_oop_mode : 0x%x" % narrow_oop_mode)

align = f.read(3)

narrow_klass_shift = struct.unpack("<l",f.read(4))
print("narrow_klass_shift : 0x%x" % narrow_klass_shift)
NARROW_KLASS_SHIFT = narrow_klass_shift[0]

misc_data_patching_offset = struct.unpack("<q",f.read(8))
print("misc_data_patching_offset : 0x%x" % misc_data_patching_offset)

serialized_data_offset = struct.unpack("<q", f.read(8))
print("serialized_data_offset : 0x%x" % serialized_data_offset)

i2i_entry_code_buffers_offset = struct.unpack("<q", f.read(8))
print("i2i_entry_code_buffers_offset : 0x%x" % i2i_entry_code_buffers_offset)
i2i_entry_code_buffers_size = struct.unpack("<q", f.read(8))
print("i2i_entry_code_buffers_size : 0x%x" % i2i_entry_code_buffers_size)

heap_end = struct.unpack("<q", f.read(8))
print("heap_end: 0x%x" % heap_end)
base_archive_is_default = struct.unpack("<B", f.read(1))
print("base_archive_is_default: 0x%x" % base_archive_is_default)

print("jvm_ident : %s" % (f.read(JVM_IDENT_MAX)))

align = f.read(7)

base_archive_name_size = struct.unpack("<Q", f.read(8))
print("base_archive_name_size : 0x%x" % base_archive_name_size)

shared_path_table_offset = struct.unpack("<Q", f.read(8))
print("shared_path_table_offset : 0x%x" % shared_path_table_offset)
shared_path_table_size = struct.unpack("<l", f.read(4))
print("shared_path_table_size : 0x%x" % shared_path_table_size)

app_class_path_start_index = struct.unpack("<h", f.read(2))
print("app_class_path_start_index : 0x%x" % app_class_path_start_index)
app_module_path_start_index = struct.unpack("<h", f.read(2))
print("app_module_path_start_index : 0x%x" % app_module_path_start_index)
num_module_paths = struct.unpack("<h", f.read(2))
print("num_module_paths : 0x%x" % num_module_paths)
max_used_path_index = struct.unpack("<h", f.read(2))
print("max_used_path_index : 0x%x" % max_used_path_index)

verify_local = struct.unpack("<B", f.read(1))
print("verify_local : 0x%x" % verify_local)
verify_remote = struct.unpack("<B", f.read(1))
print("verify_remote : 0x%x" % verify_remote)
has_platform_or_app_class = struct.unpack("<B", f.read(1))
print("has_platform_or_app_class : 0x%x" % has_platform_or_app_class)    

align = f.read(1)

requested_base_address = struct.unpack("<Q", f.read(8))
print("requested_base_address : 0x%x" % requested_base_address)   
assert(requested_base_address != SHAREDBASEADDRESS)
mapped_base_address = struct.unpack("<Q", f.read(8))
print("mapped_base_address : 0x%x" % mapped_base_address)

allow_archiving_with_java_agent = struct.unpack("<B", f.read(1))
print("allow_archiving_with_java_agent : 0x%x" % allow_archiving_with_java_agent)   

align = f.read(7)

ptrmap_size_in_bits = struct.unpack("<Q", f.read(8))
print("ptrmap_size_in_bits : 0x%x" % ptrmap_size_in_bits)

f.close()


# search juicy klass ptr
find_klass_ptr(b"[B")
find_klass_ptr(b"SignVerifier")
find_klass_ptr(b"ResultGenerator")
find_klass_ptr(b"KeyLoader")



