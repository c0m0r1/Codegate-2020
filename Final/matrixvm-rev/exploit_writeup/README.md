## MatrixVM-rev
MatrixVM is a JIT compiler. It consists of part1 and part2, which are reverse and pwn respectively.
Since JIT version of MatrixVM is so buggy, I wrote naive C implementation for rev chal.

## Distribution
The matrixvm binary and vm bytecode file (prob.mv)

## Features
The VM has 6 opcodes: `new_matrix`, `multiply_matrix`, `index_read`, `index_write`, `index_move`, `branch`   
* `new_matrix` creates a new matrix with initialized values.  
* `multiply_matrix` multiplies two matrices.  
* `index_read` and `index_write` are I/O instructions that print/read the content of matrices.  
* `index_move` is an instruction that moves a component of a register from one to another.  
* `branch` is a conditional jump statement that jumps if the [0,0] component of the operand matrix is nonzero.  

I planted a feature that prints the bytecode in a pretty fashion. Also, it analyzes the control flow and validates the code. For example, out of bounds index access and usage of undefined matrices is asserted out effectively. Also, you can't define a matrix twice, so it has similar properties with SSA. Below is an example.

```
block0
  b0:i0 m1337 = [0, 0, 0, 0] as [2 x 2]
  goto b1

block1
  b1:i0 write(m1337[0,0])
  if m1337[0,0] goto b1 else goto b2

block2
  b2:i0 m1337[0,0] = m1337[1,1]
  exit
```

You can do this by `print`ing a `TranslationUnit` for bytecode. For example, enter the line `println!("{}", &t1)` in `main.rs` after `t1` is created. Then you can see the bytecode in a pretty fashion.

## solve
Since rust source code of matrixvm is published in `matrixvm-pwn` challenge, Reversing features of matrixvm is quite trival. (at least i think...)
Also player can write simple assembler for matrixvm bytecode with knowledge above. (or using secret bytecode printing feature of rust version matrixvm.)
The given program is simple flag checker that has 6 major steps.

### 0. init several constant
 init several constant matrix for further calculation.
  - 13100 -> 1 x 300 constant metrix (contains value of 0~300)
  - 13101 -> 2 x 1 add transform matrix
  - 13102 -> 2 x 1 sub transform matrix
  - 13103 -> 1 x 2 arithmetic lvalue matrix
  - 13104 -> 1 x 1 temp value matrix (mainly used for branch)
### 1. read flag from input
  - bunch of index_read instruction
  - input stored in matrix 1000  (5 x 5) -> `flag length == 25`

### 2. matrix multiplication
 - 1001 -> 5 x 5 key matrix for encrypt input 
 (has value [119, 101, 95, 119, 105, 108, 108, 95, 109, 105, 115, 115, 95, 121, 111, 117, 95, 112, 114, 111, 99, 102, 115, 46, 46])
 - perform `matrix multiplication with matrix  1000 x matrix 1001`
 - result stored in `matrix 1003`
### 3. matrix addition
 - some repeated code pattern -> add two matrix element
    ```
    b0:i34 m13103[0,0] = m1003[0,0]
    b0:i35 m13103[0,1] = m1002[0,0]
    b0:i36 m2000 = m13103 x m13101
    b0:i37 m1003[0,0] = m2000[0,0]
    ```
 - 1002 -> 5 x 5 key matrix for encrypt input
 (has value [41546, 8619, 53491, 12367, 19810, 56577, 60086, 27970, 20573, 9151, 3554, 50732, 45063, 30800, 48142, 44842, 8366, 10332, 53130, 7242, 28114, 45541, 46379, 9801, 10691])
 - perform `matrix addition -> matrix 1003 + matrix 1002`

### 4. matrix subtraction
- some repeated code pattern -> sub two matrix element
  ```
  b0:i135 m13103[0,0] = m1003[4,3]
  b0:i136 m13103[0,1] = m1004[0,0]
  b0:i137 m2025 = m13103 x m13102
  b0:i138 m1003[4,3] = m2025[0,0]
  ```
 - 1004 -> 5 x 5 shuffled result matrix
 (has value [66767, 74378, 98601, 96720, 115270, 59426, 95089, 80703, 115942, 59188, 58826, 82702, 108504, 102446, 102655, 64693, 89909, 70993, 101607, 53330, 102259, 59728, 64083, 66997, 103118])
 - perform `matrix subtraction -> matrix 1003 - matrix 1002`
 - note that subtraction of each element are randomly shuffled
### 5. matrix element check
 - check all element of matrix 1003 are zero.
 - if all matrix element is zero, print `correct!`
 - else, print `wrong!`

### Summary
 Let's 
  - flag matrix be `F`
  - multiplicated key matrix be `K1 `
  - added key matrix be `K2`
  - un-shuffled result matrix be `R`

Then, result matrix should satisfy 
 `(F x K1) + K2 - R = 0`
By simple math, we can calculate flag matrix
 `F = (R - K2) x K1 ^ -1`
